building rag with custom unstructured data - hugging face open-source ai cookbookhugging facemodelsdatasetsspacespostsdocsenterprisepricinglog insign upopen-source ai cookbook documentationbuilding rag with custom unstructured dataopen-source ai cookbook🏡 view all resourcesaudio coursecommunity computer vision coursedeep rl coursediffusion courseml for 3d courseml for games coursenlp courseopen-source ai cookbooksearch documentationenkotrzh-cnopen-source ai cookbookoverviewllm recipesautomatic embeddings with tei through inference endpointsmigrating from openai to open llms using tgi's messages apiadvanced rag on huggingface documentation using langchainsuggestions for data annotation with setfit in zero-shot text classificationfine-tuning a code llm on custom code on a single gpuprompt tuning with peftrag with hugging face and milvusrag evaluationusing llm-as-a-judge for an automated and versatile evaluationdetecting issues in a text dataset with cleanlabannotate text data using active learning with cleanlabbuilding a rag system with gemma, elasticsearch and open source modelsbuilding a rag system with gemma, mongodb and open source modelssimple rag using hugging face zephyr and langchainrag "librarian" using llamaindeximplementing semantic cache to improve a rag system.rag with source highlighting using structured generationbuilding rag with custom unstructured datafine-tuning llm to generate persian product catalogs in json formatllm gateway for pii detectioninformation extraction with haystack and nuextractcode search with vector embeddings using qdrantrag backed by sql and jina rerankergenerate a preference dataset with distilabelclean an existing preference dataset with llms as judgesbenchmarking tgienhancing rag reasoning with knowledge graphscomputer vision recipesdiffusion recipesmultimodal recipessearch recipesagents recipesenterprise hub cookbookoverviewinteractive development in hf spacesinference api (serverless)inference endpoints (dedicated)data annotation with argilla spacescreating demos with spaces and gradiojoin the hugging face communityand get access to the augmented documentation experiencecollaborate on models, datasets and spacesfaster examples with accelerated inferenceswitch between documentation themessign upto get started       building rag with custom unstructured data authored by: maria khalusova if you’re new to rag, please explore the basics of rag first in this other notebook, and then come back here to learn about building rag with custom data. whether you’re building your own rag-based personal assistant, a pet project, or an enterprise rag system, you will quickly discover that a lot of important knowledge is stored in various formats like pdfs, emails, markdown files, powerpoint presentations, html pages, word documents, and so on. how do you preprocess all of this data in a way that you can use it for rag?in this quick tutorial, you’ll learn how to build a rag system that will incorporate data from multiple data types. you’ll use unstructured for data preprocessing, open-source models from hugging face hub for embeddings and text generation, chromadb as a vector store, and langchain for bringing everything together. let’s go! we’ll begin by installing the required dependencies:   copied !pip install -q torch transformers accelerate bitsandbytes sentence-transformers unstructured[all-docs] langchain chromadb langchain_community next, let’s get a mix of documents. suppose, i want to build a rag system that’ll help me manage pests in my garden. for this purpose, i’ll use diverse documents that cover the topic of ipm (integrated pest management): pdf: https://www.gov.nl.ca/ecc/files/env-protection-pesticides-business-manuals-applic-chapter7.pdf powerpoint: https://ipm.ifas.ufl.edu/pdfs/citrus_ipm_090913.pptx epub: https://www.gutenberg.org/ebooks/45957 html: https://blog.fifthroom.com/what-to-do-about-harmful-garden-and-plant-insects-and-pests.html feel free to use your own documents for your topic of choice from the list of document types supported by unstructured: .eml, .html, .md, .msg, .rst, .rtf, .txt, .xml, .png, .jpg, .jpeg, .tiff, .bmp, .heic, .csv, .doc, .docx, .epub, .odt, .pdf, .ppt, .pptx, .tsv, .xlsx.   copied !mkdir -p "./documents"!wget https://www.gov.nl.ca/ecc/files/env-protection-pesticides-business-manuals-applic-chapter7.pdf -o "./documents/env-protection-pesticides-business-manuals-applic-chapter7.pdf"!wget https://ipm.ifas.ufl.edu/pdfs/citrus_ipm_090913.pptx -o "./documents/citrus_ipm_090913.pptx"!wget https://www.gutenberg.org/ebooks/45957.epub3.images -o "./documents/45957.epub"!wget https://blog.fifthroom.com/what-to-do-about-harmful-garden-and-plant-insects-and-pests.html -o "./documents/what-to-do-about-harmful-garden-and-plant-insects-and-pests.html"  unstructured data preprocessing you can use the unstructured library to preprocess documents one by one, and write your own script to walk through a directory, but it’s easier to use a local source connector to ingest all documents in a given directory. unstructured can ingest documents from local directories, s3 buckets, blob storage, sftp, and many other places your documents might be stored in. the ingestion from those sources will be very similar differing mostly in authentication options.here you’ll use local source connector, but feel free to explore other options in the unstructured documentation. optionally, you can also choose a destination for the processed documents - this could be mongodb, pinecone, weaviate, etc. in this notebook, we’ll keep everything local.   copied # optional cell to reduce the amount of logsimport logginglogger = logging.getlogger("unstructured.ingest")logger.root.removehandler(logger.root.handlers[0])   copied >>> import os>>> from unstructured.ingest.connector.local import simplelocalconfig>>> from unstructured.ingest.interfaces import partitionconfig, processorconfig, readconfig>>> from unstructured.ingest.runner import localrunner>>> output_path = "./local-ingest-output">>> runner = localrunner(...     processor_config=processorconfig(...         # logs verbosity...         verbose=true,...         # the local directory to store outputs...         output_dir=output_path,...         num_processes=2,...     ),...     read_config=readconfig(),...     partition_config=partitionconfig(...         partition_by_api=true,...         api_key="your_unstructured_api_key",...     ),...     connector_config=simplelocalconfig(...         input_path="./documents",...         # whether to get the documents recursively from given directory...         recursive=false,...     ),... )>>> runner.run() info: numexpr defaulting to 2 threads. let’s take a closer look at the configs that we have here. processorconfig controls various aspects of the processing pipeline, including output locations, number of workers, error handling behavior, logging verbosity and more. the only mandatory parameter here is the output_dir - the local directory where you want to store the outputs. readconfig can be used to customize the data reading process for different scenarios, such as re-downloading data, preserving downloaded files, or limiting the number of documents processed. in most cases the default readconfig will work. in the partitionconfig you can choose whether to partition the documents locally or via api. this example uses api, and for this reason requires unstructured api key. you can get yours here.  the free unstructured api is capped at 1000 pages, and offers better ocr models for image-based documents than a local installation of unstructured.if you remove these two parameters, the documents will be processed locally, but you may need to install additional dependencies if the documents require ocr and/or document understanding models. namely, you may need to install poppler and tesseract in this case, which you can get with brew:   copied !brew install poppler!brew install tesseract if you’re on windows, you can find alternative installation instructions in the unstructured docs. finally, in the simplelocalconfig you need to specify where your original documents reside, and whether you want to walk through the directory recursively. once the documents are processed you’ll find 4 json files in the local-ingest-output directory, one per document that was processed.unstructured partitions all types of documents in a uniform manner, and returns json with document elements. document elements have a type, e.g. narrativetext, title, or table, they contain the extracted text, and metadata that unstructured was able to obtain. some metadata is common for all elements, such as filename of the document the element is from. other metadata depends on file type or element type. for example, a table element will contain table’s representation as html in the metadata, and metadata for emails will contain information about senders and recipients. let’s import element objects from these json files.   copied from unstructured.staging.base import elements_from_jsonelements = []for filename in os.listdir(output_path):    filepath = os.path.join(output_path, filename)    elements.extend(elements_from_json(filepath)) now that that you have extracted the elements from the documents, you can chunk them to fit the context window of the embeddings model.  chunking if you are familiar with chunking methods that split long text documents into smaller chunks, you’ll notice that unstructured’s chunking methods slightly differ, since the partitioning step already divides an entire document into its structural elements: titles, list items, tables, text, etc. by partitioning documents this way, you can avoid a situation where unrelated pieces of text end up in the same element, and then same chunk. now, when you chunk the document elements with unstructured, individual elements are already small so they will only be split if they exceed the desired maximum chunk size. otherwise, they will remain as is. you can also optionally choose to combine consecutive text elements such as list items, for instance, that will together fit within chunk size limit.   copied from unstructured.chunking.title import chunk_by_titlechunked_elements = chunk_by_title(    elements,    # maximum for chunk size    max_characters=512,    # you can choose to combine consecutive elements that are too small    # e.g. individual list items    combine_text_under_n_chars=200,) the chunks are ready for rag. to use them with langchain, you can easily convert unstructured elements to langchain documents.   copied from langchain_core.documents import documentdocuments = []for chunked_element in chunked_elements:    metadata = chunked_element.metadata.to_dict()    metadata["source"] = metadata["filename"]    del metadata["languages"]    documents.append(document(page_content=chunked_element.text, metadata=metadata))  setting up the retriever this example uses chromadb as a vector store and baai/bge-base-en-v1.5 embeddings model, feel free to use any other vector store.   copied from langchain_community.vectorstores import chromafrom langchain.embeddings import huggingfaceembeddingsfrom langchain.vectorstores import utils as chromautils# chromadb doesn't support complex metadata, e.g. lists, so we drop it here.# if you're using a different vector store, you may not need to do thisdocs = chromautils.filter_complex_metadata(documents)embeddings = huggingfaceembeddings(model_name="baai/bge-base-en-v1.5")vectorstore = chroma.from_documents(documents, embeddings)retriever = vectorstore.as_retriever(search_type="similarity", search_kwargs={"k": 3}) if you plan to use a gated model from the hugging face hub, be it an embeddings or text generation model, you’ll need to authenticate yourself with your hugging face token, which you can get in your hugging face profile’s settings.   copied from huggingface_hub import notebook_loginnotebook_login()  rag with langchain let’s bring everything together and build rag with langchain.in this example we’ll be using llama-3-8b-instruct from meta. to make sure it can run smoothly in the free t4 runtime from google colab, you’ll need to quantize it.   copied from langchain.prompts import prompttemplatefrom langchain.llms import huggingfacepipelinefrom transformers import pipelineimport torchfrom transformers import autotokenizer, automodelforcausallm, bitsandbytesconfigfrom langchain.chains import retrievalqa   copied model_name = "meta-llama/meta-llama-3-8b-instruct"bnb_config = bitsandbytesconfig(    load_in_4bit=true, bnb_4bit_use_double_quant=true, bnb_4bit_quant_type="nf4", bnb_4bit_compute_dtype=torch.bfloat16)model = automodelforcausallm.from_pretrained(model_name, quantization_config=bnb_config)tokenizer = autotokenizer.from_pretrained(model_name)terminators = [tokenizer.eos_token_id, tokenizer.convert_tokens_to_ids("<|eot_id|>")]text_generation_pipeline = pipeline(    model=model,    tokenizer=tokenizer,    task="text-generation",    temperature=0.2,    do_sample=true,    repetition_penalty=1.1,    return_full_text=false,    max_new_tokens=200,    eos_token_id=terminators,)llm = huggingfacepipeline(pipeline=text_generation_pipeline)prompt_template = """<|start_header_id|>user<|end_header_id|>you are an assistant for answering questions using provided context.you are given the extracted parts of a long document and a question. provide a conversational answer.if you don't know the answer, just say "i do not know." don't make up an answer.question: {question}context: {context}<|eot_id|><|start_header_id|>assistant<|end_header_id|>"""prompt = prompttemplate(    input_variables=["context", "question"],    template=prompt_template,)qa_chain = retrievalqa.from_chain_type(llm, retriever=retriever, chain_type_kwargs={"prompt": prompt})  results and next steps now that you have your rag chain, let’s ask it about aphids. are they a pest in my garden?   copied question = "are aphids a pest?"qa_chain.invoke(question)["result"] output:   copied yes, aphids are considered pests because they feed on the nutrient-rich liquids within plants, causing damage and potentially spreading disease. in fact, they're known to multiply quickly, which is why it's essential to control them promptly. as mentioned in the text, aphids can also attract ants, which are attracted to the sweet, sticky substance they produce called honeydew. so, yes, aphids are indeed a pest that requires attention to prevent further harm to your plants! this looks like a promising start! now that you know the basics of preprocessing complex unstructured data for rag, you can continue improving upon this example. here are some ideas: you can connect to a different source to ingest the documents from, for example, an s3 bucket. you can add return_source_documents=true in the qa_chain arguments to make the chain return the documents that were passed to the prompt as context. this can be useful to understand what sources were used to generate the answer. if you want to leverage the elements metadata at the retrieval stage, consider using hugging face agents and creating a custom retriever tool as described in this other notebook. there are many things you could do to improve search results. for instance, you could use hybrid search instead of a single similarity-search retriever. hybrid search combines multiple search algorithms to improve the accuracy and relevance of search results. typically it’s a combination of keyword-based search algorithms with vector search methods. have fun building rag applications with unstructured data! < > update on github ←rag with source highlighting using structured generationfine-tuning llm to generate persian product catalogs in json format→building rag with custom unstructured dataunstructured data preprocessingchunkingsetting up the retrieverrag with langchainresults and next steps